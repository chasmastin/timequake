/** * timequake by Chas - the class for the distortion effect forked from: */// http://wonderfl.net/c/Ar5I// forked from matacat's RIPPLEpackage{    import flash.display.Bitmap;    import flash.display.BitmapData;    import flash.display.Graphics;    import flash.display.Sprite;    import flash.events.Event;    import flash.events.MouseEvent;    import flash.filters.DisplacementMapFilter;    import flash.geom.Matrix;    import flash.geom.Rectangle;    import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.Sprite;	import flash.events.ActivityEvent;	import flash.events.ContextMenuEvent;	import flash.events.Event;	import flash.filters.ConvolutionFilter;	import flash.geom.Point;	import flash.media.Camera;	import flash.media.Video;	import flash.text.TextField;	import flash.events.StatusEvent;	import net.hires.debug.Stats;	import flash.events.TimerEvent;	import flash.utils.Timer;	import flash.filters.*;	import flash.filters.ColorMatrixFilter;    import fl.motion.AdjustColor;        public class timequake extends Sprite    {        protected var video:Video;		protected var camera:Camera = Camera.getCamera();          protected var bmpd:BitmapData;          		var myBlur:BlurFilter = new BlurFilter();        private var checkers:Bitmap = new Bitmap();                private var canvas:Sprite = new Sprite();        private var g:Graphics;                private var dmf:DisplacementMapFilter = new DisplacementMapFilter();        private var dmfdd:Function;                private var ripples:Ripple;        private var ir:Number;                private var wz:int;        private var hi:int;        private var checkSize:int = 10;				private var timeline1:timeline = new timeline();				private var myTimer:Timer = new Timer(1000);				private var stats:Stats = new Stats();		        var color : AdjustColor;		var colorMatrix : ColorMatrixFilter;		var matrix : Array;		var filterBW : Array;		var CGLogo1 : CGLogo = new CGLogo();                public function timequake()        {			import flash.display.StageDisplayState;			stage.displayState = StageDisplayState.FULL_SCREEN;			            wz = 1280;            hi = 720;              setCamera()             var check:BitmapData = new BitmapData(checkSize, checkSize, true, 0);            var rt:Rectangle     = new Rectangle(0, 0, checkSize / 2, checkSize / 2);            check.fillRect(rt, 0xFF000000);            rt.x = rt.y = rt.width;            check.fillRect(rt, 0xFF000000);                        g = canvas.graphics;                        var mx:Matrix = new Matrix();            mx.createGradientBox(wz, hi, Math.PI / 2);            g.beginGradientFill("linear", [0xFFFFFF, 0x404040], [1, 1], [0, 255], mx);            g.drawRect(0, 0, wz, hi);            g.beginBitmapFill(check);            g.drawRect(0, 0, wz, hi);            			            var checkersData:BitmapData = new BitmapData(wz, hi, false);            checkersData.draw(canvas);                        checkers.bitmapData = checkersData;            addChild(checkers);			addChild(CGLogo1);			            g.clear();            g.beginFill(0x000080);            g.drawRect(0, 0, wz, hi);                        dmf.mapBitmap  = new BitmapData(wz, hi, false, 0x000080);            dmf.componentX = dmf.componentY = 4;  // blue channel            dmf.scaleX     = dmf.scaleY     = 30;            dmf.mode       = "ignore";            dmfdd          = dmf.mapBitmap.draw;            //addChild(new Bitmap(dmf.mapBitmap));  // for debug                        Ripple.wz = wz;            Ripple.hi = hi;            ripples   = new Ripple();            ir        = Ripple.ir;                        stage.addEventListener(MouseEvent.CLICK, clickListener);            			// color filter			color = new AdjustColor();			color.brightness = 80;			color.contrast = 10;			color.hue = 0;			color.saturation = -100;			matrix = color.CalculateFinalFlatArray();			colorMatrix = new ColorMatrixFilter(matrix);			filterBW = [colorMatrix];                    }                protected function setCamera():void{                    var camera:Camera = Camera.getCamera();		  camera.setMode(1280,760,30);		            if (camera != null) {              video = new Video(1280,720);              video.attachCamera(camera);			   camera.addEventListener(StatusEvent.STATUS, statusHandler);               camera.addEventListener(ActivityEvent.ACTIVITY, onActivity);          camera.addEventListener(Event.DEACTIVATE, onDeactivate);              //addChild(video);          }else {              //var txt:TextField = addChild(new TextField()) as TextField;              //txt.text = "No Camera!";          }      }      	  protected function statusHandler(event:StatusEvent):void 		{ 			if (camera.muted) 			{ 				trace("Unable to connect to active camera."); 			} 			else 			{ 				// Resize Video object to match camera settings and  				// add the video to the display list. 				//video.width = camera.width; 				//video.height = camera.height; 				//addChild(video); 			} 			// Remove the status event listener. 			camera.removeEventListener(StatusEvent.STATUS, statusHandler); 		}	  	  	  // return an int of the x position we should 	  // use to plot the ripple	  protected  function positionFromTimeInSeconds():int{            // create time segments            var theDate = new Date();            var seconds = theDate.getSeconds();            var minutes = theDate.getMinutes();            var hours = theDate.getHours();									var totalseconds = (hours * 3600) + (minutes * 60) + seconds;			var position = (totalseconds * 1280)/86400;  // devide by seconds in a day...            return position;	}	  	        protected function onActivity(e:ActivityEvent):void {          if (e.activating == true) {                            // DO STUFF WITH CAMERA              setFilter();              //setBall();          }else{              //var txt:TextField = addChild(new TextField()) as TextField;              //txt.text = "No Camera!";          }      }            protected function setFilter():void {          if (!bmpd) bmpd = new BitmapData(video.width, video.height, false, 0x000000);          var bmp:Bitmap = addChild(new Bitmap(bmpd)) as Bitmap;                   bmpd.draw(video);          checkers.bitmapData = bmpd;		  addChild(checkers);       		 // start the clock		 myTimer.addEventListener(TimerEvent.TIMER, secondsWave);		 myTimer.start();                    addEventListener(Event.ENTER_FRAME, onEnter);          function onEnter(e:Event):void {            bmpd.draw(video);			addChild(timeline1);			timeline1.y = 356;						// show FPS			//addChild( stats );			video.filters = filterBW;						// flip			checkers.scaleX = -1;			checkers.x = 1280;						// logo			//addChild(CGLogo1);			//CGLogo1.x = 0;			//CGLogo1.y = 660;          }      }                  protected function onDeactivate(e:Event):void {           // var txt:TextField = addChild(new TextField()) as TextField;           // txt.text = "No Camera!";      }        private function clickListener(e:MouseEvent):void        {            var r:Ripple = ripples;            var prev:Ripple;                        do {                if (!r.isActive) break;                prev = r;            } while (r = r.next);                        if (!r) r = prev.next = new Ripple();                        r.x        = e.stageX;            r.y        = e.stageY;            r.scaleX   = r.scaleY = 0;            r.isActive = true;            canvas.addChild(r);            			if (!stage.hasEventListener(Event.ENTER_FRAME)){ 	           addEventListener(Event.ENTER_FRAME, update);			}        }        				// fire the wave		private function secondsWave(e:TimerEvent):void{						//trace("Seconds:" + positionFromTimeInSeconds());							var r:Ripple = ripples;            var prev:Ripple;                        do {                if (!r.isActive) break;                prev = r;            } while (r = r.next);                        if (!r) r = prev.next = new Ripple();            			// need to update x based on seconds in day - need to compare with time            r.x        = positionFromTimeInSeconds();            r.y        = 368;            r.scaleX   = r.scaleY = 0;            r.isActive = true;            canvas.addChild(r);            			if (!stage.hasEventListener(Event.ENTER_FRAME)){	            addEventListener(Event.ENTER_FRAME, update);			}						}                private function update(e:Event):void        {            var r:Ripple   = ripples;            var ex:Boolean = false;                        do {                if (r.isActive) {                    ex = true;                                        var s:Number = r.scaleX = r.scaleY += 0.025;                    r.alpha      = 1 - s / ir;                    					//trace("ir:" + ir + "  s:" + s);					                    if (s > 3) {                        r.isActive = false;                        canvas.removeChild(r);						//trace("ripple removed");                    }                }            } while (r = r.next);                        dmfdd(canvas);            checkers.filters = [dmf];                        if (!ex) removeEventListener(Event.ENTER_FRAME, update);        }    }}import flash.display.Shape;import flash.geom.Matrix;class Ripple extends Shape{    public static var wz:int;    public static var hi:int;    public static var ir:Number;        private static var b:uint       = 0x0000FF;    private static var k:uint       = 0x000030;    private static var colors:Array = [  b,   b,   k,   b,   b];    private static var alphas:Array = [  0, 0.2, 0.4, 0.8,   0];    private static var ratios:Array = [1, 10, 100, 50, 255];    private static var mx:Matrix;        public var isActive:Boolean = false;    public var next:Ripple;    		    public function Ripple()    {        if (!mx) {            mx = new Matrix();            mx.createGradientBox(wz, hi, 0, -wz / 2, -hi / 2);            ir = ratios[ratios.length - 1] / ratios[0] * 11.8284;        }                graphics.beginGradientFill("radial", colors, alphas, ratios, mx);        graphics.drawRect( -wz / 2, -hi / 2, wz, hi);    }}